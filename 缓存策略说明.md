# 记账插件缓存策略说明

## 🚀 优化目标

- **即时响应**：新增记账记录后立即可见
- **性能优化**：避免重复扫描大量文件
- **智能更新**：只在文件真正变化时刷新

## 📋 缓存策略

### 1. 文件监听机制
```javascript
// 监听日记文件的变化
app.vault.on('modify', (file) => {
    if (file.path.startsWith('journals/') && file.path.endsWith('.md')) {
        // 立即清除缓存，下次访问时重新加载
        this.clearCache();
    }
});
```

### 2. 短时间缓存
- **缓存时间**：30秒（而不是5分钟）
- **触发条件**：
  - 文件修改 → 立即清除缓存
  - 文件创建 → 立即清除缓存  
  - 文件删除 → 立即清除缓存
  - 超过30秒 → 自动过期

### 3. 智能加载
```javascript
// 使用场景分析
if (缓存有效 && 没有文件变化) {
    return 缓存数据;  // 秒级响应
} else {
    重新扫描文件;     // 确保数据最新
    更新缓存;
}
```

## 🎯 用户体验

### ✅ 新增记账记录
1. 在日记中写入：`#cy 15.5 豆浆油条`
2. 保存文件 → 自动触发缓存清除
3. 打开记账界面 → 立即显示新记录

### ✅ 频繁查看统计
1. 第一次打开 → 扫描所有文件（可能较慢）
2. 30秒内再次打开 → 使用缓存（秒开）
3. 修改记账后打开 → 自动刷新数据

### ✅ 强制刷新
- 点击"刷新数据"按钮 → 忽略缓存，强制重新加载

## 🔧 技术实现

### 文件扫描优化
```javascript
// 分批处理，避免阻塞
const batchSize = 10;
for (let i = 0; i < files.length; i += batchSize) {
    const batch = files.slice(i, i + batchSize);
    // 并行处理这一批文件
    const results = await Promise.all(batch.map(processFile));
}
```

### 快速过滤
```javascript
// 先检查文件是否包含记账标识符
const content = await vault.read(file);
if (!content.includes('#')) {
    return []; // 跳过不包含记账记录的文件
}
```

## 📊 性能对比

| 场景 | 优化前 | 优化后 |
|------|--------|--------|
| 首次加载 | 扫描所有文件 | 扫描所有文件 |
| 重复查看 | 每次扫描 | 使用缓存（秒开） |
| 新增记录后 | 手动刷新 | 自动检测更新 |
| 大量文件 | 线性增长 | 分批+并行处理 |

## 💡 使用建议

1. **正常使用**：无需手动刷新，系统会自动检测文件变化
2. **数据异常**：点击"刷新数据"按钮强制更新
3. **性能考虑**：插件会自动优化，无需担心文件数量

这样既保证了数据的实时性，又优化了性能表现！